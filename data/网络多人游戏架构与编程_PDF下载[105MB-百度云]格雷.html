网络多人游戏架构与编程 PDF下载 格雷 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711545779
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711545779
<p>书名:网络多人游戏架构与编程</p><p>作者:格雷</p><p>页数:未知</p><p>定价:¥109.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-10-01</p><p>ISBN:9787115457790</p><p><h2>本书特色</h2></p>[<p>
网络多人游戏已经成为游戏产业的重要组成部分，本书是一本深入探讨关于网络多人游戏编程的图书。
全书分为13章，从网络游戏的基本概念、互联网、伯克利套接字、对象序列化、对象复制、网络拓扑和游戏案例、延迟、抖动和可靠性、改进的延迟处理、可扩展性、安全性、真实世界的引擎、玩家服务、云托管专用服务器等方面深入介绍了网络多人游戏开发的知识，既全面又详尽地剖析了众多核心概念。
本书的多数示例基于C  编写，适合对C  有一定了解的读者阅读。本书既可以作为大学计算机相关专业的指导教程，也可以作为普通读者学习网络游戏编程的参考指南。
                                        </p>]<p><h2>内容简介</h2></p>[<p>网络多人游戏是一个数十亿美元级的业务，其中的一些游戏吸引了数以千万计的玩家。在这本实用且代码丰富的指南中，作者将指导你完成多人游戏开发的各个方面，他们将带你构建一个具有健壮性的多人游戏架构，并创建各个引擎级的系统。你将通过深入的代码示例来学习两个完整的游戏：一个动作游戏和一个实时战略（RTS）游戏。
首先，本书从游戏开发zhe的角度回顾网络和网络编程的基本要素。接下来讲解管理游戏数据传输、通过网络更新游戏对象和组织加入游戏的设备。你将学习如何在互联网固有的不一致性前提下，确保可靠的性能，以及如何设计游戏代码以实现zui大的安全性和可扩展性。zui后，本书以解决两个关键问题结束：结合玩家服务和将游戏托管在云端。
作者在美国南加州大学的多人游戏编程课程对本书的内容进行了广泛的测试，学生和正向网络游戏迁移的游戏开发zhe都会从中受益。
本书包括以下内容：
游戏如何进化以应对网络环境的挑战；
在游戏开发中使用互联网通信协议和标准；
使用多人网络游戏中广泛应用的Berkeley Socket；
规范游戏数据格式，实现高效的互联网传输；
同步状态，使得所有玩家共享同一个世界；
组织大型游戏的网络拓扑；
解决引起等待及数据丢失的延迟和抖动问题；
在不影响性能的前提下扩展游戏；
打击安全漏洞和软件作弊；
利用当前流行游戏引擎?D?DUnreal 4和Unity游戏引擎；
整合玩家服务，如比赛安排、成就和排行榜；
云端运行游戏服务器。 </p>]<p><h2>作者简介</h2></p>[<p>Joshua Glazer是Naked Sky Entertainment的CTO和创始人之一。Naked Sky Entertainment是一个游戏开发工作室，开发了很多游戏，如RoboBlitz、MicroBot、Twister Mania和手机端游戏Max Axe、Scrap Force。他为许多项目提供咨询，包括Epic Games公司的《虚幻引擎》（Unreal Engine）、Riot Games公司的《英雄联盟》（League of Legends）、THQ公司《毁灭全人类》（Destroy All Humans），还包括艺电（Electronic Arts）、Midway、微软（Microsoft）和派拉蒙电影公司（Paramount Pictures）等公司的很多项目。Joshua也是南加州大学（USC）的兼职讲师，讲授多人游戏编程和游戏引擎开发。
Sanjay Madhav是南加州大学（USC）的gao级讲师，讲授游戏编程、游戏引擎、数据结构和编译器知识。他在艺电（Electronic Arts）、Neversoft和Pandemic Studio做过开发zhe，涉足的游戏有《荣誉勋章：血战太平洋》（Medal of Honor: Pacific Assault）、《托尼霍克极限滑板8》（Tony Hawk’s Project 8）、《指环王：征服》（Lord of the Rings: Conquest）和《破坏者》（The Saboteur）等。他也是《Game Programming Algorithms and Techniques》的作者之一。</p>]<p><h2>目录</h2></p>
    第1章　网络游戏概述	1
1.1　多人游戏的简要历程	1
1.1.1　本地多人游戏	1
1.1.2　早期网络多人游戏	1
1.1.3　多用户网络游戏	2
1.1.4　局域网游戏	3
1.1.5　在线游戏	3
1.1.6　大规模多人在线游戏	4
1.1.7　移动网络游戏	4
1.2　星际围攻：部落	5
1.2.1　平台数据包模块	7
1.2.2　连接管理器	7
1.2.3　流管理器	8
1.2.4　事件管理器	8
1.2.5　ghost管理器	8
1.2.6　移动管理器	9
1.2.7　其他系统	9
1.3　帝国时代	10
1.3.1　轮班计时器	11
1.3.2　同步	12
1.4　总结	13
1.5　复习题	13
1.6　延伸的阅读资料	14
第2章　互联网	15
2.1　起源：分组交换	15
2.2　TCP/IP模型	17
2.3　物理层	18
2.4　链路层	18
2.5　网络层	22
2.5.1　IPv4	23
2.5.2　IPv6	36
2.6　传输层	37
2.6.1　UDP	38
2.6.2　TCP	39
2.7　应用层	48
2.7.1　DHCP	49
2.7.2　DNS	49
2.8　NAT	50
2.9　总结	56
2.10　复习题	57
2.11　延伸的阅读资料	58
第3章　伯克利套接字	61
3.1　创建Socket	61
3.2　API操作系统差异	63
3.3　socket地址	66
3.3.1　类型安全	68
3.3.2　用字符串初始化sockaddr	70
3.3.3　绑定socket	73
3.4　UDP Socket	74
3.5　TCP Socket	79
3.5.1　通过连接的socket实现发送和接收	80
3.5.2　类型安全的TCP Socket	82
3.6　阻塞和非阻塞I/O	84
3.6.1　多线程	85
3.6.2　非阻塞I/O	86
3.6.3　Select	88
3.7　其他Socket选项	92
3.8　总结	94
3.9　复习题	94
3.10　延伸的阅读资料	95
第4章　对象序列化	97
4.1　序列化的需求	97
4.2　流	100
4.2.1　内存流	101
4.2.2　字节存储次序的兼容性	105
4.2.3　比特流	109
4.3　引用数据	115
4.3.1　内联或嵌入	116
4.3.2　链接	117
4.4　压缩	119
4.4.1　稀疏数组压缩	120
4.4.2　熵编码	121
4.4.3　定点	123
4.4.4　几何压缩	125
4.5　可维护性	127
4.5.1　抽象序列化方向	127
4.5.2　数据驱动的序列化	129
4.6　总结	132
4.7　复习题	133
4.8　延伸的阅读资料	134
第5章　对象复制	135
5.1　世界状态	135
5.2　复制对象	135
5.2.1　对象创建注册表	139
5.2.2　一个数据包中的多个对象	143
5.3　朴素的世界状态复制方法	144
5.4　世界状态中的变化	148
5.5　RPC作为序列化对象	155
5.6　自定义解决方案	158
5.7　总结	159
5.8　复习题	160
5.9　延伸的阅读资料	160
第6章　网络拓扑和游戏案例	161
6.1　网络拓扑	161
6.1.1　客户端-服务器	161
6.1.2　对等网络	163
6.2　客户端-服务器的实现	165
6.2.1　服务器和客户端的代码分离	166
6.2.2　网络管理器和欢迎新客户端	167
6.2.3　输入共享和客户端代理	172
6.3　对等网络的实现	177
6.3.1　欢迎新对等体和开始游戏	179
6.3.2　命令共享和锁步回合制	181
6.3.3　保持同步	187
6.4　总结	192
6.5　复习题	192
6.6　延伸的阅读资料	193
第7章　延迟、抖动和可靠性	195
7.1　延迟	195
7.1.1　非网络延迟	195
7.1.2　网络延迟	198
7.2　抖动	199
7.3　数据包丢失	201
7.4　可靠性：TCP还是UDP	202
7.5　数据包传递通知	204
7.5.1　标记传出的数据包	205
7.5.2　接收数据包并发送确认	206
7.5.3　接收确认并传递状态	211
7.6　对象复制可靠性	216
7.7　模拟真实世界的条件	224
7.8　总结	226
7.9　复习题	227
7.10　延伸的阅读资料	228
第8章　改进的延迟处理	229
8.1　沉默的客户终端	229
8.2　客户端插值	231
8.3　客户端预测	233
8.3.1　航位推测法	236
8.3.2　客户端移动预测和重放	238
8.3.3　通过技巧和优化隐藏延迟	243
8.4　服务器端回退	244
8.5　总结	245
8.6　复习题	246
8.7　延伸的阅读资料	246
第9章　可扩展性	247
9.1　对象范围和相关性	247
9.1.1　静态区域	248
9.1.2　使用视锥	249
9.1.3　其他可见性技术	250
9.1.4　不可见时的相关性	252
9.2　服务器分区	253
9.3　实例化	255
9.4　优先级和频率	255
9.5　总结	256
9.6　复习题	257
9.7　延伸的阅读资料	257
第10章　安全性	259
10.1　数据包嗅探	259
10.1.1　中间人攻击	259
10.1.2　在主机上的数据包嗅探	262
10.2　输入验证	263
10.3　软件作弊检测	264
10.3.1　维尔福反作弊系统	265
10.3.2　典狱长反作弊系统	266
10.4　保护服务器	267
10.4.1　分布式拒绝服务攻击	267
10.4.2　坏数据	267
10.4.3　时序攻击	268
10.4.4　入侵	269
10.5　总结	270
10.6　复习题	271
10.7　延伸的阅读资料	271
第11章　真实世界的引擎	273
11.1　虚幻引擎4	273
11.1.1　套接字和基本的网络体系	273
11.1.2　游戏对象和拓扑	274
11.1.3　Actor复制	275
11.1.4　远程过程调用	276
11.2　Unity	277
11.2.1　传输层API	278
11.2.2　游戏对象和拓扑	278
11.2.3　生成对象和复制	279
11.2.4　远程过程调用	279
11.2.5　比赛安排	280
11.3　总结	280
11.4　复习题	281
11.5　延伸的阅读资料	281
第12章　玩家服务	283
12.1　选择一种玩家服务	283
12.2　基本设置	283
12.2.1　初始化、运行和关闭	285
12.2.2　用户ID和名称	286
12.3　游戏大厅和比赛安排	287
12.4　网络	291
12.5　玩家统计	294
12.6　玩家成就	299
12.7　排行榜	300
12.8　其他服务	302
12.9　总结	303
12.10　复习题	303
12.11　延伸的阅读资料	304
第13章　云托管专用服务器	305
13.1　托管或不托管	305
13.2　行业工具	306
13.2.1　REST	307
13.2.2　JSON	307
13.2.3　Node.JS	308
13.3　概述和术语	308
13.3.1　服务器游戏实例	309
13.3.2　游戏服务器进程	309
13.3.3　游戏服务器	310
13.3.4　硬件	311
13.4　本地服务器进程管理器	311
13.5　虚拟机管理器	318
13.6　总结	327
13.7　复习题	328
13.8　延伸的阅读资料	328
附录A　现代C  基础	329



