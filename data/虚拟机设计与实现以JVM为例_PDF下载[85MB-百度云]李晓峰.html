虚拟机设计与实现以JVM为例 PDF下载 李晓峰 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711552728
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711552728
<p>书名:虚拟机设计与实现以JVM为例</p><p>作者:李晓峰</p><p>页数:368</p><p>定价:¥129.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2020-01-01</p><p>ISBN:9787115527288</p><p><h2>本书特色</h2></p>[<p>
本书从一位虚拟机（VM）架构师的角度，以易于理解、层层深入的方式介绍了各种主题和算法，尤其是不同VM通用的主要技术。这些算法用图示充分解释，用便于理解的代码片段实现，使得这些抽象概念对系统软件工程师而言具像化并可编程。书中还包括一些同类文献中较少涉及的主题，例如运行时辅助、栈展开和本地接口。本书集理论性与实践性于一身，不仅结合了高层设计功能与底层实现，而且还结合了高级主题与商业解决方案，是VM设计和工程实践方面的理想参考读物。
                                        </p>]<p><h2>内容简介</h2></p>[<p>在当今的计算系统中，虚拟机已经变得无处不在--从物联网节点到移动电话、个人计算机，再到云平台。因其所能赋予软件的一些重要属性，如安全性、高生产率和可移植性，虚拟机一直吸引着软件研究人员和开发者的兴趣和关注。 本书旨在通过循序渐进、通俗易懂的方式讲解虚拟机的通用技术，主要以JVM设计为例，并兼顾其他虚拟机。本书还包括一些同类文献中较少涉及的主题，例如运行时辅助、栈展开和本地接口。本书是虚拟机设计和工程实践方面的理想参考读物，读者若掌握书中的知识点，便能为任意一种语言虚拟机的设计开发打下坚实的基础。 ● 虚拟机基础：类型、内部组成、数据结构 ● 虚拟机设计：执行引擎设计、垃圾回收设计、线程设计 ● 虚拟机内部支持：本地接口、栈展开、垃圾回收支持、运行时辅助，等等 ● 垃圾回收（GC）优化：针对吞吐量的GC优化、针对可扩展性的GC优化、针对响应性的GC优化、并发移动式回收 ● 线程交互优化：monitor性 “本书论述了关于虚拟机设计与实现的高级主题，已经成为我不可或缺的参考书。我向系统软件开发者，尤其是托管运行时系统的开发者，强烈推荐本书，因为本书能够清晰地解答他们在探索虚拟机相关话题时所产生的疑问。”——周志德，Futurewei Technologies首席科学家 “当前语言虚拟机的应用范围越来越广，各类新的语言虚拟机也层出不穷，虚拟机技术的专业图书却不多见。本书是作者多年研究与实践的心得与沉淀，值得一读。”——胡子昂，华为硅谷基础软件实验室主任、华为Fellow “关于虚拟机架构的设计，本书不但阐明了是什么，而且讨论了为什么。作者从架构师的角度高屋建瓴地分析了技术选择背后的来龙去脉，相信读者一定会受益匪浅。”——慎熙鹏，北卡罗来纳州立大学计算机系教授 “虚拟机技术在编程语言、编译器、计算机架构、Web系统等领域均有深远的影响。作者具备这些领域的工作经历，本书的写作也扎根于其在虚拟机研究及开发过程中的一手资料。本书通过循序渐进的方式，将虚拟机技术融入丰富的示例与代码中，使得读者能够同时在理论和实践的层面充分理解虚拟机技术的精髓。”——朱子青，英伟达高级软件架构师 “本书作者来自工业界，有着丰富的工程实践经验。书中同时包含了学术界在虚拟机相关领域的研究成果。其中重要的技术讨论，既有代码示例，又有理论分析，能帮助读者透彻地理解虚拟机技术的要点、难点。”——林子超，美国高通研发总监 </p>]<p><h2>作者简介</h2></p>[<p>【作者简介】 李晓峰（Xiao-Feng Li） 长期从事系统软件的研究与开发，在并行计算、操作系统、编译器和语言设计方面有着丰富的技术经验。Apache Harmony JVM的主要贡献者，所创建的一个微内核VM被发展为Intel Micro Runtime。目前在一家大型科技公司任技术副总裁，致力于定义和开发基于移动和智能设备的下一代分布式操作系统。拥有计算机科学博士学位，在闲暇时热衷于人机交互方式的探索。 【译者简介】 单业 计算机专业硕士，软件工程师，曾供职于多家软件公司，从事软件开发工作，现居于上海。译有《你不知道的JavaScript》中卷及下卷。</p>]<p><h2>目录</h2></p>
    第 一部分 虚拟机基础第 1章 虚拟机简介　21.1 虚拟机类型　21.2 为什么需要虚拟机　31.3 虚拟机示例　41.3.1 JavaScript引擎　41.3.2 Perl引擎　51.3.3 Android Java VM　51.3.4 Apache Harmony　6第 2章 虚拟机内部组成　72.1 虚拟机核心组件　72.1.1 加载器与动态链接器　72.1.2 执行引擎　82.1.3 内存管理器　82.1.4 线程调度器　92.1.5 语言扩展　92.1.6 传统模型与虚拟机模型　102.2 虚拟ISA　112.2.1 JVM　122.2.2 JVM与CLR　15第3章 虚拟机中的数据结构　173.1 对象与类　173.2 对象表示　183.3 方法描述　18第二部分 虚拟机设计第4章 执行引擎设计　224.1 解释器　224.1.1 超级指令　234.1.2 选择性内联　234.2 JIT编译　234.2.1 基于方法的JIT　244.2.2 基于踪迹的JIT　264.2.3 基于区域的JIT　294.3 解释器与JIT编译器的关系　304.4 AOT编译　314.5 编译时与运行时　33第5章 垃圾回收设计　375.1 对象生存期　375.2 引用计数　385.3 对象追踪　405.4 RC与对象追踪　425.5 GC安全点　435.6 常用追踪GC算法　455.6.1 标记清除　465.6.2 追踪复制　465.7 常用追踪GC变体　485.7.1 标记压缩　485.7.2 滑动压缩　485.7.3 追踪转发　495.7.4 标记复制　505.7.5 分代式GC　505.8 移动式GC与非移动式GC　535.8.1 数据局部性　535.8.2 跳增指针分配　535.8.3 空闲列表与分配位图　535.8.4 离散大小列表　545.8.5 标记位与分配位　545.8.6 线程局部分配　555.8.7 移动式GC与非移动式GC的混合　56第6章 线程设计　586.1 什么是线程　586.2 内核线程与用户线程　596.3 VM线程到OS线程的映射　616.4 同步构件　636.5 monitor　656.5.1 互斥　656.5.2 条件变量　666.5.3 monitorenter　666.5.4 monitorexit　696.5.5 Object.wait()　716.5.6 Object.notify()　716.6 原子　736.7 monitor与原子　756.7.1 阻塞与非阻塞　756.7.2 中央控制点　756.7.3 锁与非锁　756.7.4 非阻塞之上的阻塞　766.8 回收器与修改器　776.9 线程局部数据　786.10 GC的线程暂停支持　816.10.1 GC安全点　816.10.2 GC安全区域　836.10.3 基于锁的安全点　866.10.4 回收中的线程交互　87第三部分 虚拟机内部支持第7章 本地接口　927.1 为何需要本地接口　927.2 从托管代码到本地代码的转换　937.2.1 本地方法封装　947.2.2 封装代码的GC支持　967.2.3 封装代码的同步支持　987.3 本地方法实现的绑定　997.4 本地代码到托管代码的转换　997.5 本地代码到本地代码的转换　1027.5.1 通过JNI API的本地到本地转换　1027.5.2 为什么在本地到本地转换中使用JNI API　105第8章 栈展开　1078.1 为何需要栈展开　1078.2 Java方法帧的栈展开　1088.2.1 栈展开设计　1088.2.2 栈展开实现　1108.3 本地方法帧的栈展开　1128.3.1 栈展开设计　1128.3.2 Java到本地封装设计　1148.3.3 栈展开实现　1168.3.4 本地帧与C帧　117第9章 垃圾回收支持　1199.1 为何需要垃圾回收支持　1199.2 在Java代码中支持垃圾回收　1219.2.1 GC-map　1219.2.2 带寄存器的栈展开　1249.3 在本地代码中支持垃圾回收　1269.3.1 对象引用访问　1279.3.2 对象句柄实现　1299.3.3 GC安全性维护　1329.3.4 对象体访问　1339.3.5 对象分配　1359.4 在同步方法中支持垃圾回收　1369.4.1 同步Java方法　1369.4.2 同步本地方法　1389.5 Java与本地代码转换中的GC支持　1409.5.1 本地到Java　1409.5.2 Java到本地　1429.5.3 本地到本地　1429.6 全局根集　144第 10章 运行时辅助　14510.1 为何需要运行时辅助　14510.2 带运行时辅助的VM服务设计　14710.2.1 运行时辅助操作　14710.2.2 运行时辅助实现　14810.2.3 JNI API作为运行时辅助　15010.3 没有运行时辅助的VM服务设计　15110.3.1 运行时辅助的快速路径　15310.3.2 快速路径VM服务编程　15410.4 主要VM服务　154第 11章 异常抛出　15711.1 保存异常抛出上下文　15711.1.1 VM保存的上下文　15811.1.2 Linux中OS保存的上下文　15811.1.3 Windows中OS保存的上下文　15911.1.4 同步与异步异常　16011.2 本地代码内与跨本地代码异常处理　16111.2.1 本地代码内的异常处理　16111.2.2 带异常Java代码返回到本地代码　16211.2.3 带异常的本地代码返回到Java代码　16611.3 保存栈轨迹　16711.4 找到异常处理器　16911.5 控制转移　17211.5.1 控制转移操作　17211.5.2 用于控制转移的寄存器　17311.5.3 数据寄存器恢复　17411.5.4 控制寄存器修正　17611.5.5 执行恢复　17611.5.6 未捕获异常　179第 12章 终结与弱引用　18012.1 终结　18012.2 为何需要弱引用　18212.3 对象生存期状态　18412.3.1 对象状态转换　18512.3.2 引用队列　18712.3.3 引用对象状态转换　18712.4 引用对象实现　18912.5 引用对象处理顺序　191第 13章 虚拟机模块化设计　19413.1 VM组件　19413.2 对象信息暴露　19713.3 垃圾回收器接口　19913.4 执行引擎接口　20213.5 跨组件优化　203第四部分 垃圾回收优化第 14章 针对吞吐量的GC优化　20814.1 部分堆回收与全堆回收之间的适应性调整　20814.2 分代式与非分代式算法之间的适应性调整　21314.3 堆的空间大小的适应性调整　21714.3.1 空间大小扩展　21814.3.2 NOS大小　21914.3.3 部分转发NOS设计　22114.3.4 半空间NOS设计　22114.3.5 aged-mature NOS设计　22314.3.6 回退回收　22514.4 分配空间之间的适应性调整　22514.5 大OS页与预取　230第 15章 针对可扩展性的GC优化　23215.1 回收阶段　23215.2 并行对象图遍历　23315.2.1 任务共享　23415.2.2 工作偷取　23415.2.3 任务推送　23515.3 并行对象标记　23815.4 并行压缩　23915.4.1 并行LISP2压缩器　23915.4.2 对象依赖树　24115.4.3 带用于转发指针的目标表的压缩器　24415.4.4 基于对象节的压缩器　24615.4.5 单趟就地压缩器　247第 16章 针对响应性的GC优化　24916.1 区域式GC　24916.2 并发追踪　25216.2.1 起始快照　25216.2.2 增量更新　25616.2.3 用三色术语表示并发追踪　25916.2.4 使用读屏障的并发追踪　26016.3 并发根集枚举　26116.3.1 并发根集枚举设计　26216.3.2 在根集枚举过程中追踪堆　26516.3.3 并发栈扫描　26616.4 并发回收调度　26716.4.1 调度并发根集枚举　26716.4.2 调度并发堆追踪　26916.4.3 并发回收调度　27116.4.4 并发回收阶段转换　272第 17章 并发移动式回收　27717.1 并发复制：“目标空间不变”　27717.1.1 基于槽位的“目标空间不变”算法　27717.1.2 “目标空间不变”性　28017.1.3 对象转发　28217.1.4 基于对象的“目标空间不变”算法　28317.1.5 基于虚拟内存的“目标空间不变”算法　28517.2 并发复制：“当前副本不变”　28617.2.1 对象移动风暴　28617.2.2 “当前副本不变”设计　28717.2.3 并发复制与并发堆追踪的关系　28917.3 并发复制：“源空间不变”　29217.3.1 “源空间不变”设计　29217.3.2 部分转发“源空间不变”设计　29417.4 无STW的完整并发移动　29517.5 并发压缩回收　29617.5.1 并发区域复制式回收　29617.5.2 基于虚拟内存的并发压缩　299第五部分 线程交互优化第 18章 monitor性能优化　30818.1 惰性锁　30818.2 瘦锁　31018.2.1 瘦锁锁定路径　31018.2.2 瘦锁解锁路径　31318.2.3 竞争标志重置支持　31618.3 胖锁　31818.3.1 整合monitor数据结构　31818.3.2 交由OS来支持　31918.3.3 瘦锁膨胀为胖锁　32118.3.4 休眠等待被竞争瘦锁　32418.4 Tasuki锁　32718.4.1 将同一个胖锁monitor用于竞争控制　32718.4.2 胖锁收缩为瘦锁　33118.5 线程局部锁 33418.5.1 锁保留　33518.5.2 线程亲密锁　339第 19章 基于硬件事务内存的设计　34619.1 硬件事务内存　34619.1.1 从事务数据库到事务内存　34619.1.2 Intel的HTM实现　34719.2 使用HTM的monitor实现　34819.2.1 基于HTM的monitor的正确性问题　34919.2.2 基于HTM的monitor的性能问题　35219.3 使用HTM的并发垃圾回收　35519.3.1 GC中HTM的机会　35519.3.2 复制式回收　35719.3.3 压缩式回收　360参考文献　364
