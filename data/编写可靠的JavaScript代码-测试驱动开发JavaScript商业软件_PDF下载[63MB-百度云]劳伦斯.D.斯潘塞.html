编写可靠的JavaScript代码-测试驱动开发JavaScript商业软件 PDF下载 劳伦斯.D.斯潘塞 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244397
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244397
<p>书名:编写可靠的JavaScript代码-测试驱动开发JavaScript商业软件</p><p>作者:劳伦斯.D.斯潘塞</p><p>页数:492</p><p>定价:¥69.8</p><p>出版社:清华大学出版社</p><p>出版日期:2016-08-01</p><p>ISBN:9787302443971</p><p><h2>本书特色</h2></p>[<p>
本书分为5个部分：
 第ⅰ部分“奠定坚实的基础”涵盖了软件工程的关键概念，例如solid和dry原
则，还讨论了单元测试和测试驱动开发的优点。
 在第ⅱ部分“测试基于模式的代码”中，我们描述并使用测试驱动开发创建了
几个有用的代码模式。
 第ⅲ部分“测试和编写高级javascript特性”描述了如何使用和测试
javascript语言更高级的特性。
 第ⅳ部分“测试中的特殊主题”提供了测试dom操作的样例，还演示了用于增
强代码标准的静态分析工具的使用。
第ⅴ部分“总结”回顾了测试驱动开发的概念，还展示了一些本书用到的javascript习
语。
                                        </p>]<p><h2>内容简介</h2></p>[<p>    本书分为5个部分： 第ⅰ部分“奠定坚实的基础”涵盖了软件工程的关键概念，例如solid和dry原则，还讨论了单元测试和测试驱动开发的优点。 在第ⅱ部分“测试基于模式的代码”中，我们描述并使用测试驱动开发创建了几个有用的代码模式。 第ⅲ部分“测试和编写高级javascript特性”描述了如何使用和测试javascript语言更高级的特性。 第ⅳ部分“测试中的特殊主题”提供了测试dom操作的样例，还演示了用于增强代码标准的静态分析工具的使用。第ⅴ部分“总结”回顾了测试驱动开发的概念，还展示了一些本书用到的javascript习语。 </p>]<p><h2>作者简介</h2></p>[<p>    　Lawrence D. Spencer领导SeerIS的一个国际开发者团队，SeerIS公司是波士顿附近的一家软件和服务公司。他拥有超过35年的工作经验，曾经担任过管理人员、开发人员、咨询师以及讲师，经常出席编程大会。　　Seth H. Richards从2002年开始一直专业制作软件。他的工作专注于基于Web的企业级地理信息系统应用。</p>]<p><h2>目录</h2></p>
    目    录     第ⅰ部分  奠定坚实的基础    第1章  实践软件工程 3    1.1  编写从开始就正确的代码 4    1.1.1  掌握javascript的特性 4    1.1.2  在大型系统中规避javascript陷阱 15    1.1.3  应用软件工程原则 17    1.2  编写保持正确的代码 22    1.2.1  投资单元测试的未来 22    1.2.2  实践测试驱动开发 22    1.2.3  编写易于测试的代码 23    1.3  小结 26    第2章  准备工具 27    2.1  使用测试框架 27    2.1.1  辨别不正确的代码 30    2.1.2  可测试性设计 32    2.1.3  编写*少的代码 33    2.1.4  安全维护和重构 33    2.1.5  可运行规范 34    2.1.6  当前的开源和商业框架 34    2.1.7  介绍jasmine 36    2.2  使用依赖注入框架 41    2.2.1  依赖注入的定义 41    2.2.2  使用依赖注入让代码更可靠 43    2.2.3  掌握依赖注入 43    2.2.4  案例研究：编写一个轻量级依赖注入框架 43    2.2.5  使用依赖注入框架 50    2.2.6  当前的依赖注入框架 52    2.3  使用切面工具 53    2.3.1  案例研究：使用和不使用aop进行缓存 53    2.3.2  案例研究：构建aop.js模块 55    2.3.3  其他aop库 67    2.3.4  结论 68    2.4  使用代码检查工具 68    2.4.1  使用linting工具让代码更可靠 68    2.4.2  jshint简介 71    2.4.3  其他工具 73    2.4.4  严格模式 74    2.5  小结 74    第3章  构造可靠的对象 75    3.1  使用原生数据 75    3.2  使用对象字面量 77    3.3  使用模块模式 78    3.3.1  创建任意模块 78    3.3.2  创建立即执行模块 79    3.3.3  创建可靠的模块 80    3.4  使用对象原型和原型继承 80    3.4.1  默认对象原型 80    3.4.2  原型继承 81    3.4.3  原型链 82    3.5  使用new创建对象 83    3.6  使用类继承 88    3.6.1  模拟类继承 88    3.6.2  重复将杀死kangaroo 89    3.7  使用函数式继承 91    3.8  猴子补丁(monkey-patching) 92    3.9  小结 95    第ⅱ部分  测试基于模式的代码    第4章  浏览各种模式的优点 99    4.1  案例分析 99    4.2  通过更广泛的词汇产生更加优雅的代码 100    4.3  使用拥有良好设计、良好测试的构建块产生可靠的代码  101    4.4  小结 102    第5章  确保回调模式的正确使用 103    5.1  通过单元测试了解回调模式 104    5.1.1  编写和测试使用了回调函数的代码 104    5.1.2  编写和测试回调函数 109    5.2  避免问题 113    5.2.1  扁平化回调箭头 113    5.2.2  注意this变量 115    5.3  小结 119    第6章  确保承诺模式的正确使用 121    6.1  通过单元测试了解承诺 122    6.1.1  使用承诺 122    6.1.2  构造和返回承诺 127    6.1.3  测试xmlhttprequest 130    6.2  串联承诺 133    6.3  使用承诺封装器 134    6.4  了解状态和命运 135    6.5  区分标准承诺和jquery承诺 135    6.6  小结 136    第7章  确保正确使用散函数应用程序 137    7.1  对散函数应用程序进行单元测试 137    7.2  为散函数应用程序创建切面 139    7.3  区分散函数应用程序和柯里化 140    7.3.1  柯里化 140    7.3.2  散函数应用程序 141    7.4  小结 141    第8章  确保备忘录模式的正确使用 143    8.1  通过单元测试了解备忘录模式 144    8.2  使用aop添加备忘录 147    8.2.1  创建备忘录切面 147    8.2.2   为restaurantapi应用returnvaluecache切面 150    8.3  小结 152    第9章  确保单例模式的正确实现 153    9.1  通过单元测试了解单例模式 154    9.1.1  使用对象字面量实现单例共享缓存 154    9.1.2  使用模块实现单例共享缓存 158    9.2  小结 162    第10章  确保工厂模式的正确实现 163    10.1  为工厂编写单元测试 163    10.2  实现工厂模式 169    10.3  考虑其他工厂类型 171    10.4  小结 171    第11章  确保沙箱模式的正确实现和使用 173    11.1  通过单元测试了解沙箱模式 173    11.1.1  创建部件沙箱 174    11.1.2  创建和测试沙箱工具 187    11.1.3  创建与沙箱一起使用的函数 191    11.2  小结 193    第12章  确保装饰器模式的正确实现 195    12.1  使用测试驱动的方式开发装饰器 196    12.1.1  为被装饰的对象编写一个假对象 197    12.1.2  为错误的传递编写测试 198    12.1.3  编写空白装饰器 199    12.1.4  添加传递功能到装饰器 200    12.1.5  验证成功传递 202    12.1.6  添加装饰器的特性 204    12.1.7  通用化装饰器 210    12.2  小结 211    第13章  确保策略模式的正确实现 213    13.1  通过单元测试了解该模式 213    13.1.1   在不使用策略模式的情况下实现transportscheduler 214    13.1.2  使用策略模式实现transportscheduler  216    13.2  小结 227    第14章  确保代理模式的正确实现 229    14.1  通过测试驱动的方式开发代理 230    14.2  小结 245    第15章  确保正确实现可链接方法 247    15.1  通过单元测试了解该模式 248    15.2  链接then方法 255    15.3  小结 257    第ⅲ部分  测试和编写高级javascript特性    第16章  在无接口语言中遵守接口 261    16.1  了解接口的优点 262    16.2  了解接口隔离原则 263    16.3  使用测试驱动开发创建契约注册表 265    16.3.1  定义契约 266    16.3.2  判断是否履行了契约 267    16.3.3  断言契约被履行了 271    16.3.4  绕过契约执行 273    16.3.5  创建在被返回(创建)的对象上实施契约的切面  273    16.4  小结 277    第17章  确保正确的参数类型 279    17.1  了解javascript无类型参数带来的机会和风险  280    17.2  扩展contractregistry检查参数  280    17.2.1  界定任务范围 280    17.2.2  判断集合中的所有变量是否都履行了它的契约  281    17.2.3  断言集合中的所有变量都履行了它的契约 289    17.2.4  在切面中打包参数检查功能 290    17.3  支持契约库 292    17.4  综合起来 293    17.4.1  创建契约模块 293    17.4.2  创建应用程序的contractregistry  296    17.4.3  为生产发布绕过契约 297    17.5  比较面向切面的解决方案和静态解决方案 297    17.5.1  考虑typescript的优点 297    17.5.2  考虑切面的优点 297    17.6  小结 298    第18章  确保正确使用call、apply和bind 299    18.1  浏览this是如何绑定的 299    18.1.1  默认绑定 300    18.1.2  隐式绑定 302    18.1.3   new绑定 303    18.1.4  显式绑定 305    18.2  创建和测试使用call、apply和bind的代码  305    18.2.1  使用call和apply 305    18.2.2   使用测试驱动开发创建一个array.prototype.foreach polyfill 307    18.2.3  使用bind 316    18.3  小结 321    第19章  确保正确使用方法借用 323    19.1  确保借用对象符合需求 324    19.1.1  让被借用的函数验证借用者的资格 324    19.1.2  向被借用的对象附加切面 326    19.1.3  使用borrow()方法 329    19.1.4  在contractregistry中添加对象验证器  330    19.2  预期借用者的副作用 331    19.2.1  考虑被隔离函数的副作用 331    19.2.2  考虑调用其他函数的函数的副作用 332    19.3  预期捐赠者对象的副作用 338    19.4  小结 339    第20章  确保正确使用混合 341    20.1  创建和使用混合 343    20.1.1  创建和使用传统混合 344    20.1.2  创建和使用函数式混合 361    20.2  小结 367    第21章  测试高级程序架构 369    21.1  确保观察者模式的可靠使用 369    21.1.1  检查观察者模式 370    21.1.2  增强观察者模式的可靠性 376    21.2  确保中介者模式的可靠使用 380    21.2.1  了解中介者模式 381    21.2.2  增强基于中介者代码的可靠性 382    21.3  小结 395    第ⅳ部分  测试中的特殊主题    第22章  测试dom访问 399    22.1  对ui进行单元测试 399    22.1.1  检查难于测试的ui代码 400    22.1.2  使用tdd创建ui组件 401    22.2  使用分析器优化代码 411    22.2.1  检测低效代码 411    22.2.2  避免不成熟的优化 418    22.3  小结 418    第23章  确保符合标准 419    23.1  使用eslint 420    23.1.1  安装eslint 420    23.1.2  运行eslint 424    23.1.3  使用eslint实施代码标准 427    23.2  实施架构分离 432    23.2.1  家庭秘密技术 433    23.2.2  铭记技术 435    23.2.3  不可能任务(mission impossible)技术  437    23.2.4  魔术棒(magic wand)    技术 441    23.2.5  不要使用调用栈技术 442    23.2.6  其他技术 442    23.2.7  其他架构 442    23.3  小结 443    第ⅴ部分  总结    第24章  测试驱动开发原则的总结 447    24.1  回顾值得使用测试驱动开发的原因 447    24.2  练习测试驱动开发 448    24.3  编写可单元测试的代码 448    24.4  掌握测试驱动开发的    技术 448    24.4.1  在编码之前编写测试 448    24.4.2  保持测试dry 449    24.4.3  首先测试错误条件 449    24.4.4  测试要先易后难 449    24.4.5  具体 449    24.4.6  只测试一件事情 450    24.4.7  测试数据如同测试一样重要 450    24.4.8  高效地使用jasmine 450    24.5  测试本书描述的模式 450    24.5.1  测试面向切面编程 450    24.5.2  测试对象构造 451    24.5.3  测试回调 451    24.5.4  测试基于承诺的代码 451    24.5.5  测试散函数应用程序 451    24.5.6  测试备忘录模式 452    24.5.7  测试单例模式 452    24.5.8  测试工厂模式 452    24.5.9  测试沙箱 452    24.5.10  测试装饰器模式 453    24.5.11  测试策略模式 453    24.5.12  测试代理模式 453    24.5.13  测试可链接方法 453    24.5.14  测试接口一致性 453    24.5.15  测试call和apply的    使用 453    24.5.16  测试方法借用模式 454    24.5.17  测试混合 454    24.5.18  测试中介者和观察者模式 454    24.5.19  测试dom访问 454    24.5.20  实施架构分离的测试 454    24.6  小结 455    第25章  本书javascript习语的总结 457    25.1  回顾对象 457    25.1.1  可以添加和删除的对象属性 457    25.1.2  可以将对象用作词典 458    25.2  回顾变量 459    25.2.1  提升变量声明 459    25.2.2  变量有函数作用域 460    25.3  回顾函数 463    25.3.1  函数是对象 463    25.3.2  提升函数声明 463    25.3.3  函数没有返回类型 464    25.3.4  函数可以是匿名的 465    25.3.5  函数可以被嵌套 465    25.3.6  函数调用可以使用任意数量的参数 466    25.3.7  函数可以立即被调用 467    25.4  回顾布尔操作 468    25.4.1  在测试相等性时类型可能会被强制转换 468    25.4.2  值可以是真或假 469    25.5  小结 469                     
