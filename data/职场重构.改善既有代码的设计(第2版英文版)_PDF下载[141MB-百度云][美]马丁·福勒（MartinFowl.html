职场重构.改善既有代码的设计(第2版英文版) PDF下载 [美]马丁·福勒（MartinFowl 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711551008
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711551008
<p>书名:职场重构.改善既有代码的设计(第2版英文版)</p><p>作者:[美]马丁·福勒（Martin Fowl</p><p>页数:407</p><p>定价:¥128.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-07-01</p><p>ISBN:9787115510082</p><p><h2>本书特色</h2></p>[<p>
本书是经典著作《重构》出版20年后的新版。书中清晰揭示了重构的过程，解释了重构的原理和*实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了60多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。
本书适合软件开发人员、项目管理人员等阅读，也可作为高等院校计算机及相关专业师生的参考读物。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书是经典著作《重构》出版20年后的新版。书中清晰揭示了重构的过程，解释了重构的原理和很好实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了60多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。
本书适合软件开发人员、项目管理人员等阅读，也可作为高等院校计算机及相关专业师生的参考读物。</p>]<p><h2>作者简介</h2></p>[<p>马丁?福勒（Martin Fowler） 软件开发大师，ThoughtWorks的科学家。他是一位作家、演说者、咨询师和泛软件开发领域的意见ling袖。他致力于改善企业级的软件设计，对设计以及支撑设计的工程实践孜孜以求。他在重构、面向对象分析设计、模式、XP和UML等领域都有贡献。著有《重构：改善既有代码的设计》《分析模式》《领域特定语言》等经典著作。</p>]<p><h2>目录</h2></p>
    Chapter 1: Refactoring: A First Example  /  重构，**个示例	1
The　Starting Point / 起点　1
Comments　on the Starting Program / 对此起始程序的评价　3
The　First Step in Refactoring / 重构的**步　5
Decomposing　the statement Function / 分解statement方法　6
Status:　Lots of Nested Functions / 进展：大量嵌套函数　22
Splitting　the Phases of Calculation and Formatting /
拆分计算阶段与格式化阶段　24
Status:　Separated into Two Files (and Phases) /
进展：分离到两个文件（和两个阶段）　31
Reorganizing　the Calculations by Type / 按类型重组计算过程　34
Status:　Creating the Data with the Polymorphic Calculator /
进展：使用多态计算器来提供数据　41
Final　Thoughts / 结语　43
Chapter　2: Principles in Refactoring / 重构的原则　45
Defining　Refactoring / 何谓重构　45
The　Two Hats / 两顶帽子　46
Why　Should We Refactor / 为何重构　47
When　Should We Refactor / 何时重构　50
Problems　with Refactoring / 重构的挑战　55
Refactoring,　Architecture, and Yagni / 重构、架构和YAGNI　62

Refactoring　and the Wider Software Development Process /
重构与软件开发过程　63
Refactoring　and Performance / 重构与性能　64
Where　Did Refactoring Come From / 重构起源何处　67
Automated　Refactorings / 自动化重构　68
Going　Further / 延展阅读　70
Chapter　3: Bad Smells in Code / 代码的坏味道　71
Mysterious　Name / 神秘命名　72
Duplicated　Code / 重复代码　72
Long　Function / 过长函数　73
Long　Parameter List / 过长参数列表　74
Global　Data / 全局数据　74
Mutable　Data / 可变数据　75
Divergent　Change / 发散式变化　76
Shotgun　Surgery / 霰弹式修改　76
Feature　Envy / 依恋情结　77
Data　Clumps / 数据泥团　78
Primitive　Obsession / 基本类型偏执　78
Repeated　Switches / 重复的switch　79
Loops　/ 循环语句　79
Lazy　Element / 冗赘的元素　80
Speculative　Generality / 夸夸其谈通用性　80
Temporary　Field / 临时字段　80
Message　Chains / 过长的消息链　81
Middle　Man / 中间人　81
Insider　Trading / 内幕交易　82
Large　Class / 过大的类　82
Alternative　Classes with Different Interfaces / 异曲同工的类　83
Data　Class / 纯数据类　83
Refused　Bequest / 被拒绝的遗赠　83
Comments　/ 注释　84
Chapter　4: Building Tests / 构筑测试体系　85
The　Value of Self-Testing Code / 自测试代码的价值　85
Sample　Code to Test / 待测试的样例代码　87
A　First Test / **个测试　90
Add　Another Test / 再添加一个测试　93
Modifying　the Fixture / 修改测试夹具　95
Probing　the Boundaries / 探测边界条件　96
Much　More Than This / 测试远不止如此　99
Chapter　5: Introducing the Catalog / 介绍重构名录　101
Format　of the Refactorings / 重构的记录格式　101
The　Choice of Refactorings / 挑选重构的依据　102
Chapter　6: A First Set of Refactorings / **组重构　105
Extract　Function / 提炼函数　106
Inline　Function / 内联函数　115
Extract　Variable / 提炼变量　119
Inline　Variable / 内联变量　123
Change　Function Declaration / 改变函数声明　124
Encapsulate　Variable / 封装变量　132
Rename　Variable / 变量改名　137
Introduce　Parameter Object / 引入参数对象　140
Combine　Functions into Class / 函数组合成类　144
Combine　Functions into Transform / 函数组合成变换　149
Split　Phase / 拆分阶段　154
Chapter　7: Encapsulation / 封装　161
Encapsulate　Record / 封装记录　162
Encapsulate　Collection / 封装集合　170
Replace　Primitive with Object / 以对象取代基本类型　174
Replace　Temp with Query / 以查询取代临时变量　178
Extract　Class / 提炼类　182
Inline　Class / 内联类　186
Hide　Delegate / 隐藏委托关系　189
Remove　Middle Man / 移除中间人　192
Substitute　Algorithm / 替换算法　195
Chapter　8: Moving Features / 搬移特性　197
Move　Function / 搬移函数　198
Move　Field / 搬移字段　207
Move　Statements into Function / 搬移语句到函数　213
Move　Statements to Callers / 搬移语句到调用者　217
Replace　Inline Code with Function Call / 以函数调用取代内联代码　222
Slide　Statements / 移动语句　223
Split　Loop / 拆分循环　227
Replace　Loop with Pipeline / 以管道取代循环　231
Remove　Dead Code / 移除死代码　237
Chapter　9: Organizing Data / 重新组织数据　239
Split　Variable / 拆分变量　240
Rename　Field / 字段改名　244
Replace　Derived Variable with Query / 以查询取代派生变量　248
Change　Reference to Value / 将引用对象改为值对象　252
Change　Value to Reference / 将值对象改为引用对象　256
Chapter　10: Simplifying Conditional Logic / 简化条件逻辑　259
Decompose　Conditional / 分解条件表达式　260
Consolidate　Conditional Expression / 合并条件表达式　263
Replace　Nested Conditional with Guard Clauses /
以卫语句取代嵌套条件表达式　266
Replace　Conditional with Polymorphism / 以多态取代条件表达式　272
Introduce　Special Case / 引入特例　289
Introduce　Assertion / 引入断言　302
Chapter　11: Refactoring APIs / 重构API　305
Separate　Query from Modifier / 将查询函数和修改函数分离　306
Parameterize　Function / 函数参数化　310
Remove　Flag Argument / 移除标记参数　314
Preserve　Whole Object / 保持对象完整　319
Replace　Parameter with Query / 以查询取代参数　324
Replace　Query with Parameter / 以参数取代查询　327
Remove　Setting Method / 移除设值函数　331
Replace　Constructor with Factory Function / 以工厂函数取代构造函数　334
Replace　Function with Command / 以命令取代函数　337
Replace　Command with Function / 以函数取代命令　344
Chapter　12: Dealing with Inheritance / 处理继承关系　349
Pull　Up Method / 函数上移　350
Pull　Up Field / 字段上移　353
Pull　Up Constructor Body / 构造函数本体上移　355
Push　Down Method / 函数下移　359
Push　Down Field / 字段下移　361
Replace　Type Code with Subclasses / 以子类取代类型码　362
Remove　Subclass / 移除子类　369
Extract　Superclass / 提炼超类　375
Collapse　Hierarchy / 折叠继承体系　380
Replace　Subclass with Delegate / 以委托取代子类　381
Replace　Superclass with Delegate / 以委托取代超类　399
Bibliography　/ 参考文献　405
