精通Oracle SQL-(第2版) PDF下载 莫顿 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535166
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535166
<p>书名:精通Oracle SQL-(第2版)</p><p>作者:莫顿</p><p>页数:530</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2014-05-01</p><p>ISBN:9787115351661</p><p><h2>相关资料</h2></p>[<p>“本书讲述清晰，可操作性强，是一本难得的oracle sql教程。” <br/>
　　——nocoug（北加州oracle用户组）杂志 <br/>
　　“本书作者全部是oaktable的成员，oracle开发经验丰富。在研究一些被其他专门讨论oracle sql语言的参考书直接忽略的问题时，这种对oracle数据库的长期钻研无疑是一个巨大的优势。” <br/>
　　——亚马逊读者评论<br/></p>]<p><h2>本书特色</h2></p>[<p>
《精通oracle sql(第2版)》语言精炼、风趣，所涵盖的内容涉及sql核心、sql执行、分析函数、联结、测试与质量保证等，并提供大量实用性建议，且总结出方方面面的“技巧”，帮助读者在阅读过程中快速消化所看内容。新版针对oracle 12c进行了大幅修订，以反映技术的*新发展动态。 
　　《精通oracle sql(第2版)》旨在为oracle数据库开发人员、dba和架构师提供参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>《精通oracle sql（第2版）》由oracle 数据库领域**技术组织oaktable成员倾力打造，第1版热卖，读者好评如潮。书中主要介绍了如何掌握在oracle数据库中实现的强大sql特性，所涵盖的内容涉及sql核心、sql执行、分析函数、联结、测试与质量保证等，并提供了大量实用的建议，总结出方方面面的“技巧”，帮助读者快速消化重要知识点。新版将数据库版本升级到12c，对旧版进行了大幅修订，并阐述了很多新特性。 
作为oracle sql经典著作，《精通oracle sql（第2版）》为sql开发人员指明了前行方向，赋予了他们不断开拓的动力。</p>]<p><h2>作者简介</h2></p>[<p>Karen Morton，研究人员、教育家及顾问，Fidelity信息服务公司资深数据库管理员和性能调优专家。她从20世纪90年代初就开始使用Oracle，从事Oracle教学工作也已经超过10年的时间。她是Oracle ACE和OakTable的成员，经常在技术会议上演讲。她的著作还包括Expert Oracle Practices和Beginning Oracle SQL。 
　　Kerry Osborne，Enkitec公司（提供Oracle咨询服务）联合创始人。从1982年开始使用Oracle（第2版）。他当过开发人员，也做过DBA，目前是Oracle ACE总监和OakTable成员。最近几年，他专注于研究Oracle内部原理以及解决性能问题。 
　　Robyn Sands，思科公司软件工程师，为思科客户设计开发嵌入式Oracle数据库产品。从1996年开始使用Oracle，在应用开发、大型系统实现以及性能评估方面具有丰富的经验。她是OakTable的成员，同时是Expert Oracle Practices 一书的合著者。 
　　Riyaj Shamsudeen，OraInternals（专注于性能/数据恢复/电子商务的咨询公司）董事长、首席数据库管理员。有近20年使用Oracle技术产品以及Oracle数据库管理员/Oracle数据库应用管理员的经验，是真正应用集群、性能调优以及数据库内部属性方面的专家。同时是一位演讲家及Oracle ACE。 
　　Jared Still，从1994年就开始使用Oracle。他认为对于SQL的学习是永无止境的，相信只有精通SQL语言才能写出查询Oracle数据库的高效语句。他参与本书的编写就是为了帮助别人实现这一目标。
</p>]<p><h2>目录</h2></p>
    第1章　sql核心　1.1　sql语言　1.2　数据库的接口　1.3　sql*plus回顾　1.3.1　连接到数据库　1.3.2　配置sql*plus环境　1.3.3　执行命令　1.4　5个核心的sql语句　1.5　select语句　1.5.1　from子句　1.5.2　where子句　1.5.3　group by子句　1.5.4　having子句　1.5.5　select列表　1.5.6　order by子句　1.6　insert语句　1.6.1　单表插入　1.6.2　多表插入　1.7　update语句　1.8　delete语句　1.9　merge语句　1.10　小结　第2章　sql执行　2.1　oracle架构基础　2.2　sga共享池　2.3　库高速缓存　2.4　完全相同的语句　2.5　sga缓冲区缓存　2.6　查询转换　2.6.1　查询块　2.6.2　视图合并　2.6.3　子查询解嵌套　2.6.4　联结消除　2.6.5　排序消除　2.6.6　谓词推进　2.6.7　使用物化视图进行查询重写　2.7　确定执行计划　2.8　执行计划并取得数据行　2.9　sql执行——总览　2.10　小结　第3章　访问和联结方法　3.1　全扫描访问方法　3.1.1　如何选择全扫描操作　3.1.2　全扫描与舍弃　3.1.3　全扫描与多块读取　3.1.4　全扫描与高水位线　3.2　索引扫描访问方法　3.2.1　索引结构　3.2.2　索引扫描类型　3.2.3　索引唯一扫描　3.2.4　索引范围扫描　3.2.5　索引全扫描　3.2.6　索引跳跃扫描　3.2.7　索引快速全扫描　3.3　联结方法　3.3.1　嵌套循环联结　3.3.2　排序—合并联结　3.3.3　散列联结　3.3.4　笛卡儿联结　3.3.5　外联结　3.4　小结　第4章　sql是关于集合的　4.1　以面向集合的思维方式来思考　4.1.1　从面向过程转变为基于集合的思维方式　4.1.2　面向过程与基于集合的思维方式：例子　4.2　集合运算　4.2.1　union和union all　4.2.2　minus　4.2.3　intersect　4.3　集合与空值　4.3.1　空值与非直观结果　4.3.2　空值与集合运算　4.3.3　空值与group by和order by　4.3.4　空值与聚合函数　4.4　小结　第5章　提出问题　5.1　问出好的问题　5.2　提问的目的　5.3　问题的种类　5.4　问题的问题　5.5　数据的问题　5.6　建立逻辑表达式　5.7　小结　第6章　sql执行计划　6.1　解释计划　6.1.1　使用解释计划　6.1.2　plan_table　6.1.3　分解计划　6.1.4　导致解释计划未达目的的原因　6.1.5　阅读计划　6.1.6　访问和筛选谓语　6.1.7　使计划便于阅读　6.2　执行计划　6.2.1　查看*近生成的sql语句　6.2.2　查看相关执行计划　6.2.3　收集执行计划统计信息　6.2.4　标识sql语句以便以后取回计划　6.2.5　深入理解dbms_xplan　6.2.6　使用sql监控报告　6.2.7　使用计划信息解决问题　6.3　小结　第7章　高级分组　7.1　基本的group by用法　7.2　having子句　7.3　group by的“新”功能　7.4　group by的cube扩展　7.5　cube的实际应用　7.6　用grouping()函数排除空值　7.7　用grouping()扩展报告　7.8　用grouping_id()扩展报告　7.9　grouping sets与rollup()　7.10　group by局限性　7.11　小结　第8章　分析函数　8.1　概览　8.2　示例数据　8.3　分析函数剖析　8.4　函数列表　8.5　聚合函数　8.5.1　跨越整个分区的聚合函数　8.5.2　细粒度窗口声明　8.5.3　默认窗口声明　8.6　lead和lag　8.6.1　语法和排序　8.6.2　例1：从前一行中返回一个值　8.6.3　理解数据行的位移　8.6.4　例2：从下一行中返回一个值　8.7　first_value和last_value　8.7.1　例子：使用first_value计算*大值　8.7.2　例子：使用last_value计算*小值　8.8　其他分析函数　8.8.1　nth_value　8.8.2　rank　8.8.3　dense_rank　8.8.4　row_number　8.8.5　ratio_to_report　8.8.6　percent_rank　8.8.7　percentile_cont　8.8.8　percentile_disc　8.8.9　ntile　8.8.10　stddev　8.8.11　listagg　8.9　性能调优　8.9.1　执行计划　8.9.2　谓词　8.9.3　索引　8.10　高级话题　8.10.1　动态sql　8.10.2　嵌套分析函数　8.10.3　并行　8.10.4　pga大小　8.11　组织行为　8.12　小结　第9章　model子句　9.1　电子表格　9.2　使用model子句实现跨行引用　9.2.1　示例数据　9.2.2　剖析model子句　9.2.3　规则　9.3　位置和符号引用　9.3.1　位置标记　9.3.2　符号标记　9.3.3　for循环　9.4　返回更新后的行　9.5　求解顺序　9.5.1　行求解顺序　9.5.2　规则求解顺序　9.6　聚合　9.7　迭代　9.7.1　示例　9.7.2　presentv与空值　9.8　查找表　9.9　空值　9.10　使用model子句进行性能调优　9.10.1　执行计划　9.10.2　谓词推进　9.10.3　物化视图　9.10.4　并行　9.10.5　model子句执行中的分区　9.10.6　索引　9.11　子查询因子化　9.12　小结　第10章　子查询因子化　10.1　标准用法　10.2　用with定义pl/sql函数　10.3　sql优化　10.3.1　测试执行计划　10.3.2　测试查询改变的影响　10.3.3　寻找其他优化机会　10.3.4　将子查询因子化应用到pl/sql中　10.4　递归子查询　10.4.1　connect by示例　10.4.2　rsf示例　10.4.3　rsf的限制条件　10.4.4　与connect by的不同点　10.5　复制connect by的功能　10.5.1　level伪列　10.5.2　sys_connect_by_path函数　10.5.3　connect_by_root运算符　10.5.4　connect_by_iscycle伪列和nocycle参数　10.5.5　connect_by_isleaf伪列　10.6　小结　第11章　半联结和反联结　11.1　半联结　11.2　半联结执行计划　11.3　控制半联结执行计划　11.3.1　使用提示控制半联结执行计划　11.3.2　在实例级控制半联结执行计划　11.4　半联结限制条件　11.5　半联结必要条件　11.6　反联结　11.7　反联结执行计划　11.8　控制反联结执行计划　11.8.1　使用提示控制反联结执行计划　11.8.2　在实例级控制反联结执行计划　11.9　反联结限制条件　11.10　反联结必要条件　11.11　小结　第12章　索引　12.1　理解索引　12.1.1　什么时候使用索引　12.1.2　列的选择　12.1.3　空值问题　12.2　索引结构类型　12.2.1　b-树索引　12.2.2　位图索引　12.2.3　索引组织表　12.3　分区索引　12.3.1　局部索引　12.3.2　全局索引　12.3.3　散列分区与范围分区　12.4　与应用特点相匹配的解决方案　12.4.1　压缩索引　12.4.2　基于函数的索引　12.4.3　反转键索引　12.4.4　降序索引　12.5　管理问题的解决方案　12.5.1　不可见索引　12.5.2　虚拟索引　12.5.3　位图联结索引　12.6　小结　第13章　select以外的内容　13.1　insert　13.1.1　直接路径插入　13.1.2　多表插入　13.1.3　条件插入　13.1.4　dml错误日志　13.2　update　13.2.1　ctas与update的差别　13.2.2　insert append与update的差别　13.3　delete　13.4　merge　13.4.1　语法和用法　13.4.2　性能比较　13.5　小结　第14章　事务处理　14.1　什么是事务　14.2　事务的acid属性　14.3　事务隔离级别　14.4　多版本读一致性　14.5　事务控制语句　14.5.1　commit(提交)　14.5.2　savepoint(保存点)　14.5.3　rollback(回滚)　14.5.4　set transaction(设置事务)　14.5.5　set constraints(设置约束)　14.6　将运算分组为事务　14.7　订单录入模式　14.8　活动事务　14.9　使用保存点　14.10　序列化事务　14.11　隔离事务　14.12　自治事务　14.13　小结　第15章　测试与质量保证　15.1　测试用例　15.2　测试方法　15.2.1　单元测试　15.2.2　回归测试　15.2.3　模式修改　15.2.4　重复单元测试　15.3　执行计划比较　15.4　性能测量　15.4.1　在代码中加入性能测量　15.4.2　性能测试　15.5　破坏性测试　15.6　使用性能测量进行系统检修　15.7　小结　第16章　计划稳定性　16.1　计划不稳定性：理解这个问题　16.1.1　统计信息的变化　16.1.2　运行环境的改变　16.1.3　sql语句的改变　16.1.4　绑定变量窥视　16.1.5　自适应游标共享　16.2　统计信息反馈　16.3　识别执行计划的不稳定性　16.3.1　抓取当前运行查询的数据　16.3.2　查看语句的性能历史　16.3.3　按照执行计划聚合统计信息　16.3.4　寻找执行计划的统计方差　16.3.5　在一个时间点附近检查偏差　16.4　小结　第17章　计划控制　17.1　执行计划控制：解决问题　17.1.1　调整查询结构　17.1.2　适当使用常量　17.1.3　给优化器一些提示　17.2　执行计划控制：不能直接访问代码　17.2.1　选项1：改变统计信息　17.2.2　选项2：改变数据库参数　17.2.3　选项3：增加或移除访问路径　17.2.4　选项4：应用基于提示的执行计划控制机制　17.2.5　大纲　17.2.6　sql概要文件　17.2.7　sql执行计划基线　17.2.8　sql补丁　17.2.9　基于提示的计划控制机理小结　17.3　小结　第18章　其他sql结构　18.1　条件逻辑结构　18.1.1　decode　18.1.2　case　18.1.3　nvl、nvl2和coalesce　18.1.4　nullif　18.2　pivot/unpivot查询　18.2.1　pivot　18.2.2　unpivot　18.3　生成测试数据的sql　18.3.1　想要得到什么样的数据　18.3.2　connect by　18.3.3　model子句　18.3.4　递归with子句　18.3.5　数据生成小结　18.4　小结
