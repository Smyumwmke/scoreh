第三方JavaScript编程 PDF下载 维尼哲 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711539224
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711539224
<p>书名:第三方JavaScript编程</p><p>作者:维尼哲</p><p>页数:237</p><p>定价:¥55.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2015-09-01</p><p>ISBN:9787115392244</p><p><h2>相关资料</h2></p>[<p>本书的作者该领域非常专业的两名开发者。<br/>
——paul irish，google chrome、jquery开发者关系团队 <br/>
本书是每一位认真编写javascript的开发者的必读之作。<br/>
—brian forester, proquest<br/>
本书对分布式前端web应用有独到的见解！<br/>
——sopan shewale ，saba软件公司<br/>
本书透彻地解释了错综复杂的第三方javascript。<br/>
——jake mccrary，drw交易集团</p>]<p><h2>本书特色</h2></p>[<p>
第三方javascript应用程序是自包含的应用组件，通常都是小脚本或插件，能够为web站点增加功能。它们往往是由独立的组织或个人提供的，代码和文件都是来自于远程的web地址。
《第三方javascript编程》由两位第三方应用程序开发领域的专家编写完成，通过丰富的示例和讲解引导读者掌握第三方web开发的相关技术及如何开发运行在第三方环境的javascript代码。《第三方javascript编程》共10章，分别介绍了第三方javascript的定义、如何加载和执行代码、dom渲染、第三方脚本和数据服务器之间的通信、跨窗口的消息传递方法、身份验证和cookie、第三方应用程序的安全性、javascript sdk的发展、性能、测试和调试。
《第三方javascript编程》并非javascript语言的初级读本，适用于有一定第三方代码开发经验的开发者以及致力于研究其如何在外部环境运行的开发者们阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1.第三方web应用开发非常火爆，同时也面临着独特的挑战，有阅读和学习的必要与需求。google的小应用和广告插件、facebook的社交和游戏插件等都是支持第三方开发的。
2.本书是首本全面探讨第三方应用开发的图书。面向的是那些已经熟悉javascript了，但想要开发第三方应用的读者。
3.本书的两位作者来自知名的互联网，第二作者还是开源javascript工具jhint的贡献者和骨干，在社区的知名度和影响力都很大。他们为英文版开辟和维护的页面，http://thirdpartyjs.com/。</p>]<p><h2>作者简介</h2></p>[<p>Ben Vinegar
Ben Vinegar 是 Disqus 的一名软件工程师，Disqus 是一个第三方评论平台，为超过 30 万的博客、在线出版物以及其它Web网站提供服务，其中包括 CNN、连线杂志、每日电讯报和 IGN。Ben 在加入 Disqus 之前，在一个非常流行的 Web 记账应用公司 FreshBooks 担任软件开发团队的主管。
Anton Kovalyov
Anton Kovalyov 是 Disqus 的一名软件工程师，在公司初期就曾主导 Disqus 评论微件的开发工作。他还参与一些 JavaScript 开源项目的开发与维护，包括代码质量工具 JSHint，和跨域通信的 JS 库 easyXDM。</p>]<p><h2>目录</h2></p>
    目录  第1章  第三方javascript介绍  11.1  第三方javascript的定义  21.2  第三方javascript的用法  41.2.1  嵌入式微件  61.2.2  分析和统计  81.2.3  web服务api封装  91.3  开发一个简单的微件  131.3.1  服务端生成脚本  141.3.2  通过******s分发微件  161.4  第三方开发的挑战  171.4.1  未知的上下文  171.4.2  共享环境  181.4.3  浏览器限制  191.5  总结  19第2章  应用的分发和加载  202.1  配置第三方开发环境  212.1.1  发布者的测试页面  212.1.2  web服务器  222.1.3  模拟多个域  232.2  加载初始的脚本  242.2.1  阻塞式脚本引入  252.2.2  使用async和defer无阻塞加载脚本  262.2.3  动态脚本插入  282.3  初始脚本文件  292.3.1  window和undefined混淆  302.3.2  基本应用程序流程  312.4  加载额外的文件  322.4.1  javascript文件  332.4.2  库  352.5  脚本参数传递  372.5.1  使用查询字符串  372.5.2  使用片段标识符  402.5.3  使用自定义数据属性  402.5.4  使用全局变量  422.6  获取应用数据  442.7  总结  45第3章  html和css的渲染  463.1  输出html  473.1.1  使用document.write  473.1.2  追加到已知位置  483.1.3  追加多个微件  503.1.4  解耦渲染对象  523.2  为你的html添加样式  533.2.1  使用内联样式  533.2.2  加载css文件  543.2.3  嵌入css到javascript中  563.3  防御性的html和css  593.3.1  命名空间593.3.2  css的特殊性  603.3.3  过度设置css的特殊性  623.4  将内容嵌入到******中  653.4.1  没有设置src的******  663.4.2  外部******  683.4.3  样式继承  693.4.4  何时避免使用******  733.5  小结  74第4章  与服务器通信  754.1  ajax和浏览器的同源策略  764.1.1  判定同源的规则  774.1.2  同源策略和脚本加载  784.2  带填充的json（jsonp）  804.2.1  通过脚本元素加载json  804.2.2  动态的回调函数  814.2.3  局限性和安全问题  844.3  子域名代理  854.3.1  使用document.domain更改文档的源  874.3.2  使用子域代理实现跨域通信  884.3.3  子域名代理与jsonp相结合  914.3.4  internet explorer和子域代理  944.3.5  安全隐患  954.4  跨源资源共享  954.4.1  发送简单的http请求  964.4.2  使用cors传输cookie  984.4.3  发送预检请求  994.4.4  浏览器支持  994.5  总结  100第5章  跨域******通信  1015.1  html5 window.postmessage api  1025.1.1  使用window.postmessage发送信息  1035.1.2  接收发送给窗口的消息  1045.1.3  浏览器的支持  1065.2  降级技术  1075.2.1  使用window.name发送消息  1085.2.2  使用url片段标识符发送消息  1115.2.3  使用flash发送消息  1135.3  使用easyxdm简化跨域消息通信  1165.3.1  加载并初始化easyxdm  1165.3.2  使用easyxdm.socket发送简单信息  1185.3.3  使用easyxdm.rpc定义json-rpc接口  1195.4  总结  124第6章  验证和会话  1256.1  第三方cookie  1266.1.1  sessions的设置和读取  1276.1.2  禁用第三方cookie  1286.1.3  internet explorer和p3p头  1296.1.4  检测cookies是否可用  1316.2  设置第三方cookie  1346.2.1  使用独立窗口  1346.2.2  ******的解决方案（只针对safari）  1376.2.3  chrome和firefox中的单页面会话  1406.3  会话安全  1406.3.1  https和更安全的cookie  1416.3.2  多级身份认证  1426.4  总结  144第7章  安全性  1457.1  cookies，会话，和会话窃取  1467.2  跨站脚本  1477.2.1  xss攻击  1487.2.2  css中的xss漏洞  1497.2.3  防止xss对应用的攻击  1517.3  跨站请求伪造  1537.3.1  xsrf攻击  1547.3.2  json劫持  1557.3.3  保护应用免受xsrf攻击  1567.4  发布者漏洞  1587.4.1  发布者模拟  1587.4.2  点击劫持  1607.4.3  拒绝服务  1627.5  总结  162第8章  独特的框架  1638.1  实现一个*基本的sdk  1658.1.1  初始化  1668.1.2  异步加载  1678.1.3  暴露公共方法  1708.1.4  事件监听器  1708.2  版本管理  1738.2.1  url版本管理  1748.2.2  通过初始化进行版本控制  1768.3  封装web服务的apis  1788.3.1  在客户端访问web服务apis  1798.3.2  封装camera stork api  1828.3.3  识别发布者  1868.3.4  用户授权和oauth  1908.4  总结  191第9章  性能  1939.1  优化负荷  1949.1.1  合并和压缩源代码  1959.1.2  减少图像请求  1969.1.3  缓存文件  1989.1.4  推迟http请求  1999.2  javascript优化  2049.2.1  浏览器内部：ui线程，重绘和回流  2059.2.2  控制耗性能的调用：throttle和debounce函数  2069.2.3  使用settimeout延迟计算  2089.3  被感知的性能  2109.3.1  对用户的操作保持乐观  2119.3.2  在文档就绪之前渲染  2129.4  总结  213第10章  调试和测试  21510.1  调试  21610.1.1  在生产环境中使用开发环境的代码  21810.1.2  单步执行代码  22310.2  测试  22710.2.1  单元测试、集成测试和回归测试  22810.2.2  使用qunit编写回归测试  23010.2.3  使用hiro写回归测试  23310.3  总结  236
