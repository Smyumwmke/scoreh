芯片验证漫游指南——从系统理论到UVM的验证全视界 PDF下载 刘斌著 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712133901
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712133901
<p>书名:芯片验证漫游指南——从系统理论到UVM的验证全视界</p><p>作者:刘斌著</p><p>页数:22,538页</p><p>定价:¥99.0</p><p>出版社:电子工业出版社</p><p>出版日期:2018-04-01</p><p>ISBN:9787121339011</p><p><h2>本书特色</h2></p>[<p>
资深验证专家刘斌（路桑）向您全面介绍芯片验证，从验证的理论，到SystemVerilog语言和UVM验证方法学，再到高级验证项目话题。这本综合性、实用性的验证理论和编程方面的图书，针对芯片验证领域不同级别的验证工程师，给出由浅入深的技术指南：学习验证理论来认识验证流程和标准，学习SystemVerilog语言和UVM方法学来掌握目前主流的动态验证技术，了解高级验证话题在今后遇到相关问题时可以参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书介绍了芯片验证的理论实践, 并针对系统设计给出了动态验证的集成解决方案。</p>]<p><h2>作者简介</h2></p>[<p>刘斌（路桑）目前是Intel公司的资深验证专家。在Intel移动通信事业部主持验证架构规划和方法学研究，担任过几款亿门级通信芯片的验证经理角色。在工程领域之外，他在西安电子科技大学和西安交通大学客座讲授芯片验证课程。创办的验证技术订阅号“路科验证”，目前已有超过10000名的订阅者。多次在设计验证行业国际会议和展览中发表论文，并做了富有特色的演讲。在西安交通大学取得微电子专业学士学位，在瑞典皇家理工学院取得芯片设计专业硕士学位。</p>]<p><h2>目录</h2></p>
    第1章  芯片验证全视  1.1  功能验证简介  1.2  验证的处境    1.2.1  验证语言的发展    1.2.2  验证面临的挑战  1.3  验证能力的5个维度    1.3.1  完备性    1.3.2  复用性    1.3.3  高效性    1.3.4  高产出    1.3.5  代码性能  1.4  验证的任务和目标    1.4.1  按时保质低耗    1.4.2  芯片研发与客户反馈    1.4.3  缺陷增长曲线  1.5  验证的周期    1.5.1  验证周期中的检查点    1.5.2  功能详述    1.5.3  制定验证计划    1.5.4  开发验证环境    1.5.5  调试环境和HDL文件    1.5.6  回归测试    1.5.7  芯片生产    1.5.8  硅后系统测试    1.5.9  逃逸分析  1.6  本章结束语第2章  验证的策略  2.1  设计的流程    2.1.1  TLM模型的需求和ESL开发    2.1.2  传统的系统设计流程    2.1.3  ESL系统设计流程    2.1.4  语言的抽象级比较    2.1.5  传统的系统集成视角    2.1.6  ESL系统集成视角  2.2  验证的层次    2.2.1  模块级    2.2.2  子系统级    2.2.3  芯片系统级    2.2.4  硅后系统级  2.3  验证的透明度    2.3.1  黑盒验证    2.3.2  白盒验证    2.3.3  灰盒验证  2.4  激励的原则    2.4.1  接口类型    2.4.2  序列颗粒度    2.4.3  可控性    2.4.4  组件独立性    2.4.5  组合自由度  2.5  检查的方法  2.6  集成的环境    2.6.1  验证平台    2.6.2  待验设计    2.6.3  运行环境    2.6.4  验证管理  2.7  本章结束语第3章  验证的方法  3.1  动态仿真    3.1.1  定向测试    3.1.2  随机测试    3.1.3  基于覆盖率驱动的随机验证    3.1.4  基于TLM的随机验证    3.1.5  断言检查  3.2  静态检查    3.2.1  语法检查    3.2.2  语义检查    3.2.3  跨时钟域检查    3.2.4  形式验证  3.3  开发环境    3.3.1  Vim开发环境    3.3.2  商业SV开发环境——DVT  3.4  虚拟模型  3.5  硬件加速  3.6  效能验证    3.6.1  功率和能量    3.6.2  静态功耗和动态功耗    3.6.3  节能技术    3.6.4  效能验证    3.6.5  功耗预测与优化  3.7  性能验证    3.7.1  设定目标    3.7.2  测试环境    3.7.3  验证方法  3.8  趋势展望    3.8.1  技术之间的横向跨越    3.8.2  层次之间的纵向复用  3.9  本章结束语第4章  验证的计划  4.1  计划概述  4.2  计划的内容    4.2.1  技术的视角    4.2.2  项目的视角  4.3  计划的实现    4.3.1  邀请相关人员    4.3.2  开会讨论    4.3.3  确定测试场景    4.3.4  创建验证环境  4.4  计划的进程评估    4.4.1  回归测试通过率    4.4.2  代码覆盖率    4.4.3  断言覆盖率    4.4.4  功能覆盖率    4.4.5  缺陷曲线  4.5  本章结束语第5章  验证的管理  5.1  验证周期的检查清单  5.2  验证管理的三要素    5.2.1  时间管理    5.2.2  人力资源安排    5.2.3  任务拆分和重组  5.3  验证的收敛    5.3.1  回归流程    5.3.2  回归质量    5.3.3  回归效率  5.4  让漏洞无处可逃  5.5  团队建设  5.6  验证师的培养    5.6.1  全硅能力    5.6.2  不做假设    5.6.3  专注力    5.6.4  逻辑性    5.6.5 “战鼓光环”    5.6.6  降低复杂度  5.7  验证的专业化    5.7.1  对验证的偏见    5.7.2  验证面临的现状    5.7.3  验证标准化    5.7.4  验证经验的积累和突破  5.8  本章结束语第6章  验证的结构  6.1  测试平台概述  6.2  硬件设计描述    6.2.1  功能描述    6.2.2  设计结构    6.2.3  接口描述    6.2.4  接口时序    6.2.5  寄存器描述  6.3  激励发生器  6.4  监测器  6.5  比较器  6.6  验证结构    6.6.1  项目背景    6.6.2  MCDF验证进度安排  6.7  本章结束语第7章  SV环境构建  7.1  数据类型  7.2  模块定义与例化    7.2.1  模块定义    7.2.2  模块例化    7.2.3  参数使用    7.2.4  参数修改    7.2.5  宏定义  7.3  接口    7.3.1  接口连接方式1    7.3.2  接口连接方式2    7.3.3  接口的其他应用  7.4  程序和模块    7.4.1  Verilog设计竞争问题    7.4.2  SV的仿真调度机制    7.4.3  module数据采样示例1    7.4.4  module数据采样示例2    7.4.5  program数据采样示例  7.5  测试的始终    7.5.1  系统函数调用方式结束    7.5.2  program隐式结束    7.5.3  program显式结束  7.6  本章结束语第8章  SV组件实现  8.1  激励发生器的驱动    8.1.1  激励驱动的方法    8.1.2  任务和函数    8.1.3  数据生命周期    8.1.4  通过接口驱动    8.1.5  测试向量产生    8.1.6  仿真结束控制  8.2  激励发生器的封装    8.2.1  类的封装    8.2.2  类的继承    8.2.3  成员覆盖    8.2.4  虚方法    8.2.5  句柄使用    8.2.6  对象复制    8.2.7  对象回收  8.3  激励发生器的随机化    8.3.1  可随机的激励种类    8.3.2  约束求解器    8.3.3  随机变量和数组    8.3.4  约束块    8.3.5  随机化控制    8.3.6  随机化的稳定性    8.3.7  随机化的流程控制    8.3.8  随机化的系统函数  8.4  监测器的采样    8.4.1  Interface clocking简介    8.4.2  利用clocking事件同步    8.4.3  利用clocking采样数据    8.4.4  利用clocking产生激励    8.4.5  monitor的采样功能  8.5  组件间的通信    8.5.1  通知的需求    8.5.2  资源共享的需求    8.5.3  数据通信的需求    8.5.4  进程同步的需求    8.5.5  进程通信要素的比较和应用  8.6  比较器和参考模型    8.6.1  异常检查    8.6.2  常规检查    8.6.3  时序检查    8.6.4  组件连接  8.7  测试环境的报告规范    8.7.1  信息报告库    8.7.2  信息库使用场景  8.8  本章结束语第9章  SV系统集成  9.1  包的意义  9.2  验证环境的组装    9.2.1  封装验证环境的方式    9.2.2  模块环境的复用考量    9.2.3  比较器的复用考量    9.2.4  顶层环境的实现  9.3  测试场景的生成    9.3.1  动态控制激励    9.3.2  调度多个激励器    9.3.3  线程的精细控制    9.3.4  动态测试向量    9.3.5  向量群落的并发控制  9.4  灵活化的配置    9.4.1  Agent的两面性    9.4.2  各个组件的模式配置    9.4.3  验证结构的集成顺序  9.5  初论环境的复用性    9.5.1  复用的策略    9.5.2  水平复用的应用    9.5.3  垂直复用的应用  9.6  本章结束语第10章  UVM世界观  10.1  我们所处的验证时代  10.2  类库地图  10.3  工厂机制    10.3.1  工厂的意义    10.3.2  工厂提供的便利    10.3.3  覆盖方法    10.3.4  确保正确覆盖的代码要求  10.4  核心基类    10.4.1  域的自动化    10.4.2  复制    10.4.3  比较    10.4.4  打印    10.4.5  打包和解包  10.5  phase机制    10.5.1  phase执行机制    10.5.2  如何开始UVM仿真    10.5.3  如何结束UVM仿真  10.6  config机制    10.6.1  interface传递    10.6.2  变量设置    10.6.3  config object传递    10.6.4  config机制    10.6.5  其他配置方法    10.6.6  uvm_resource_db的使用  10.7  消息管理    10.7.1  消息方法    10.7.2  消息处理    10.7.3  消息机制    10.8  宏的优劣探讨    10.9  本章结束语第11章  UVM结构  11.1  组件家族    11.1.1  uvm_driver    11.1.2  uvm_monitor    11.1.3  uvm_sequencer    11.1.4  uvm_agent    11.1.5  uvm_scoreboard    11.1.6  uvm_env    11.1.7  uvm_test  11.2  把DUT装进TB分几步    11.2.1  MCDF顶层验证环境方案1    11.2.2  MCDF顶层验证环境方案2  11.3  构建环境的内经    11.3.1  环境构建的四要素    11.3.2  环境元素分类  11.4  本章结束语第12章  UVM通信  12.1  TLM通信概论  12.2  单向、双向及多向通信    12.2.1  单向通信    12.2.2  双向通信    12.2.3  多向通信  12.3  通信管道应用    12.3.1  TLM FIFO    12.3.2  Analysis Port    12.3.3  Analysis TLM FIFO    12.3.4  Request ＆ Response 通信           管道  12.4  TLM2通信    12.4.1  接口实现    12.4.2  传送数据    12.4.3  时间标记    12.4.4  典型使用  12.5  同步通信元件    12.5.1  uvm_event应用    12.5.2  uvm_barrier应用    12.5.3  uvm_callback应用  12.6  本章结束语第13章  UVM序列  13.1  新手上路  13.2  Sequence和Item    13.2.1  Sequence Item    13.2.2  Flat Sequence    13.2.3  Hierarchical Sequence  13.3  Sequencer和Driver    13.3.1  双方的TLM端口和方法    13.3.2  事务传输
